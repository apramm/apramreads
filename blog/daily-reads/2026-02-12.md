# Day 5 : Feb 12, 2026

## Two Pages Challenge

Today we start abstracting the boilerplate i.e., an example walk through the design of an entire compiler, a small one

### What I Read Today

- we start compiler design with a **fixed abstraction boundary** (an existing target language), and building a new layer of abstraction on top of it it

- GOAL => systematically design and build a new layer of abstraction, formalized as a new programming language (a source language) that can be implemented by translation into a corresponding target language

- **purpose of new abstraction?** : solve some problem, such as software development being error-prone, software design being complex, or software produced in the language being unsafe, unportable, or verbose. *Ideally*, we solve this problem without <u>introducing some cost</u>, such as a high learning curve, or some performance penalty.

- **how to solve these problems**  :
    - correct identify the problem i.e., "What is the wrong with this target language?" 
    - design an abstraction layer to address it i.e., "designing the source language that addresses those problems"
    - design a compiler (from language definitions, abstractions made) to transform the source language into target language 

- **process of building compiler** : process will be easier if focus on one problem at time and introducing *intermediate languages*, serving some *intermediate compilers* (also called compiler pass or pass)
- Each of our passes may be as simple as inserting some code, or as complex as analyzing and rewriting the structure of many pieces of interacting code i.e., can either be easily derived from language definition or designed after years of iteration to effectively implement well known abstractions

- before going tomorrow about designing abstraction, think about some problems with our target language i.e., x64


### Reflection
good read about process of building compiler and which abstractions are fixed and which are not.


---
