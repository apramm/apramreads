# Day 13 : Feb 20, 2026

## Two Pages Challenge

Today we read start reading about what's wrong with our language i.e., `Paren-x64 v1` and abstract locations

### What I Read Today

- recalling how our `Paren-x64 v1` was like
    - it provides barest of abstractions which abstracts away from the boilerplate code in `x64`  
    - also abstracts away the details of how to pass a value to the operation system

- what's lacking in `Paren-x64 v1`
    - still requires programmer to manage a small number of variables (registers) 
        - we want to make language that make computer remember more and free up human to remember less
        - this prevents human from making runtime errors thru a mistake and overwriting a register that still in use

- we've `abstract locations` to fix the issue of programmer remembering the registers by having any arbitrary number of `abstract locations` that the programmer does not need to know what physical location they end up using.

- as abstract locations cannot be 1:1 with registers as we've limited registers
    - we need to expose a little more from our `target language`

- we expose some limited access to memory in `x64`, and introduce the abstraction of a `frame variable` to help use compile abstract locations to physical locations.

i.e., we need to redesign a new language and some translations, that enable instructions to work over `abstract locations`, even though `x64` restricts what kind of `physical locations` instructions can use

---
#### Designing new source language
- how to start?
    - start by writing some programs in existing abstraction until you spot patterns you dislike

- what's the pattern in `Paren-x64 v1`?
    - all computations act on a small set of 16 registers

- is it a disliking pattern? yes if it makes programming error-prone and cumbersome 
    - limits the way we can write computations
    - We must, manually, order and collapse sub-computations to keep the number of registers that are in use small
    - We must keep track of which registers are still in use before we move a value, or we will overwrite part of our computation.
    - Furthermore, the instructions we’re given are     `idiosyncratic`—they only work with certain operands, such as requiring some integer literals to be 32-bit or 64-bit, depending on which instruction we’re using. The programmer is forced to consider the size of their data before choosing how to proceed with a computation.

- how will we improve programming?
    - allow programmer to invent new locations at will, if it helps their programming and not worry about irrelevant machine-specific restrictions on these locations


new language `Asm-lang v2` to abstract away from machine specific concerns

```

  p	 	::=	 	(module info tail)
 	 	 	 	 
  info	 	::=	 	info?
 	 	 	 	 
  tail	 	::=	 	(halt triv)
 	 	|	 	(begin effect ... tail)
 	 	 	 	 
  effect	 	::=	 	(set! aloc triv)
 	 	|	 	(set! aloc_1 (binop aloc_1 triv))
 	 	|	 	(begin effect ... effect)
 	 	 	 	 
  triv	 	::=	 	int64
 	 	|	 	aloc
 	 	 	 	 
  binop	 	::=	 	*
 	 	|	 	+
 	 	 	 	 
  aloc	 	::=	 	aloc?
 	 	 	 	 
  int64	 	::=	 	int64?
```



### Reflection

good read about some recap on our initial source language, problems with it why they're problem and possible way to tackle them. next i'll read more about new language we defined a bit here and compare with the og `Paren-x64 v1`

---
