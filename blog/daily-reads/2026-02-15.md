# Day 8 : Feb 15, 2026

## Two Pages Challenge

Today we read to understand the meaning of grammar in the source language we defined

### What I Read Today

- why we need to understand the meaning of the grammar / language?
  - optimizations depend on when various programs in a language are equivalent. We need to understand the language to understand when programs are equivalent
   - we cannot know whether the compiler is correct if we do not know the meaning of programs before they are compiled.
   - `Unit Tests`  will help us debug, but when we know the meaning of *all* programs in the language, we can say whether that meaning is preserved through compilation.

- how do we define meaning of a language?
   - we write an interpreter. here, for most of our language we assume we've an interpreter that roughly corresponds to embedding the program in Racket

- Example, `Paren-x64 v1` is an imperative language and does not return values, we must decide how to interpret a `Paren-x64 v1` program as a value
  - as there are no prexisting conventions like `x64` i.e., we define our own conventions that every program need to follow to be well-defined and produce a final value in `Paren-x64 v1`. Like having value of `rax` as the final value returned

- process of designing an interpreter for `Paren-x64 v1` 
  -  We implement a register machine: a recursive function over instruction sequences that interprets each instruction using an accumulator mapping registers to values. 
  - When there are no instructions left, the interpreter returns the value of `rax`, the register designated by our convention.

- edge case?
  - What is a register has no value before it is used? For example, what is the value of a program when rax is never initialized?

- deal with edge case
  - we add a new convention to initialize a register before it is used haha (kind of got this from `x64` as that also results in undefined behavior if register uninit)


- why this cheap way of dealing with edge case?
   - we don’t want to insert code to check every register is initialized (if that’s even possible, it would be expensive), or insert extra code to initialize registers to arbitrary values (how would we distinguish them from real values?) i.e., we simply restrict the language.


- **Undefined behaviour**
  - really strong tool to improve the ability of programmers to predict behaviour of all programs in your language.
  - common in low level languages that lack  a strong enough enforcement mechanism for checking assumptions
  - it can be too difficult to statically check an assumption or too expensive to do this dynamically i.e., we might be forced to make assumptions that we cannot enforce (injecting some undefined behaviour) NOT IDEAL

- in the interpreter atleast for `Paren-x64 v1` we assume all inputs are valid. Not only syntactically but also obeying all restrictions and conventions. As it allows to not mix the concerns and duplicate code again in interpreter def
```
procedure

(interp-paren-x64 x) → int64?

  x : paren-x64-v1?
```


### Reflection
good read today about interpreter, edge cases handling them in `Paren-x64 v1` specifically. Next it'll be nice to dive into compiler implementation

---
