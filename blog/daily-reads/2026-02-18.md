# Day 11 : Feb 18, 2026

## Two Pages Challenge

Today we read start reading about implementing runtime system and instruction sequence for a compiler

### What I Read Today

- what is a run-time system?
  - we know the abstractions defined for `Paren x64 v1` is different from `x64` i.e., to implement the conventions s.t. operating system knows what abstractions to adhere to (i.e., having result in rax register). We write some x64 code (instruction sequence) which takes in any instruction sequence implementing `Paren x64 v1` convention and communicate the result to the operating system. This code is a simple `run-time system`

- why run-time system is needed?
  - it provides all run-time support required by the language but not provided by the underlying machine
  - what support it provides depends on the abstraction provided by language, machine, operating system and ui we desire
  - Typically, the language `run-time` provides memory allocation and deallocation, provides initialization of the process environment such as the stack, handles returning values to the user, and provides any built-in procedures that all programs in the language can expect to use
  - for `Paren x64 v1`, the only run-time support we require is returning the final value to the operating system and exiting.

- what is our run-time system looking like for `Paren x64 v1`
  - we communicate via the operating system's exit code
  - This exit code is a number between 0 and 255 given to the exit system call, and is easily accessible in shells via the variable $? (or $status in some shells)
  - Therefore, this run-time system is an `x64 instruction sequence` which expects to be composed after another `instruction sequence`.
  - The run-time system assumes that the first instruction sequence must initialize `rax`. The run-time system then calls the `exit` system call with the value of rax passed as the exit code.

```
procedure

(wrap-x64-run-time x) → string?

  x : string?
```


- Finally, we implement a simple pass to turn the `instruction sequence` into a `program`, by introducing the x64 boilerplate

```
procedure

(wrap-x64-boilerplate x) → string?

  x : string?
```
This procedure takes in an `x64 instruction sequence` and wraps it with the necessary boilerplate to return a complete `x64` program in Intel syntax.


- Now we've a complete compiler, which is easily defined by composing all these individual passes
```
(define (paren-x64-v1-compiler x)
  (wrap-x64-boilerplate (wrap-x64-run-time (generate-x64 x))))
 
(define paren-x64-v1-compiler^
  (compose wrap-x64-boilerplate wrap-x64-run-time generate-x64))

```

EXAMPLES:
```
> (interp-paren-x64
   '(begin
      (set! rax 170679)
      (set! rdi rax)
      (set! rdi (+ rdi rdi))
      (set! rsp rdi)
      (set! rsp (* rsp rsp))
      (set! rbx 8991)))
183

> (current-pass-list
   (list
    check-paren-x64
    generate-x64
    wrap-x64-run-time
    wrap-x64-boilerplate))
> (execute
   '(begin
      (set! rax 170679)
      (set! rdi rax)
      (set! rdi (+ rdi rdi))
      (set! rsp rdi)
      (set! rsp (* rsp rsp))
      (set! rbx 8991))
    nasm-run/exit-code)
183

```

### Reflection
Good read as we finally completed all the passes required for a full compiler construction. Further we evaluate whether it's correct or not.

---
