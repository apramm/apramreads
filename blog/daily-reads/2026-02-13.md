# Day 6 : Feb 13, 2026

## Two Pages Challenge

Today we design abstraction and see what all is wrong with x64

### What I Read Today

- problem #1 **boilerplate** i.e., writing program in x64 requires programmer to insert repititive boilerplate like declaration of the initial label, and some code to exit the program and report the result to the user
    - the issue is that this prevents the user from focusing on the program and requires them to copy and paste the same snippets of code into their programs, an error-prone process if that snippet ever needs to change.

- solving problem #1 :
    - allow programmers to focus on writing and composing sequences of instructions, by giving those sequences meaning independent of boilerplate and runtime system (provides all run-time support required by the language but that is not provided by the underlying machine)
    - i.e., we should be able to write multiple programs independently without writing the boilerplate required by `nasm`

- we introducing `instruction sequences` => lists of instructions that represent the code of an x64 program
    - these seperate the code from boilerplate
    - this results in a notion of program composition i.e., we focus on seperate programs that can be stitched together later

- we need to apply the abstraction of instruction sequences to all x64 instructions like mov, add, imul

- Below is an example of a valid instruction sequence in our subset of x64.
```
mov rax, 170679

mov rdi, rax

add rdi, rdi

mov rsp, rdi

imul rsp, rsp

mov rbx, 8991
```

Note that this does not correspond to a x64 program, as it is missing much of the structure: the starting label, the section declarations, etc. It has no meaning on its own in `nasm`, and part of the job of our compiler is to transform it so that it does have meaning when given to nasm. 

- how to create a compiler that transforms the instruction sequence s.t. it has a meaning?
    - we represent `instruction sequences` as Racket Strings, with ea instruction seperated by new line i.e., something like : "  mov rax, 42"
    - NOTE : these strings are whitespace sens
    -  " mov rbx, 2147483648\\n add rax, rbx" and "\\nmov rbx, 2147483648\\n\\nadd rax, rbx\\n". these both are equivalent

- Now, this is really messy so, its first problem we solve in our source language i.e., move away from Racket Strings as representation of instructions

- moving forward we design a source language that captures meaning of instruction sequence and has a new representation of programs.
 


### Reflection
good read in understanding how we pick the problem and try to abstract those away and problems that can arise from abstraction.
will be good to look at source language design next!


---
