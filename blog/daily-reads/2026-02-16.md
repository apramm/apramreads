# Day 9 : Feb 16, 2026

## Two Pages Challenge

Today we read start reading about designing compiler and its enforcement mechanisms   

### What I Read Today

- Enforcement mechanisms take various forms, such as parsers, type checkers, linters, and static analyses

- how we do that?
  - we design a function `check-paren-x64` to validate the `Paren-x64 v1` programs
  - It reads an arbitrary value, expected to represent a `Paren-x64 v1` program, and returns a valid program in the language `Paren-x64 v1`, or raises an error
  - It is a trivial parser i.e., it does not transform the representation of input if it is valid, it only transforms the type, or interpretation, of the data.
  - `check-paren-x64` can be viewed as type checker. It checks for a single type: *The-Paren-x64-Type*, which every valid instruction has, and which has simple typing rules

- going forward we'll call passes like this **validator** :  a generic name for a compiler passes that does not transform the representation of data, but does transform the type or interpretation of that data.

- why we write validators?
  - return if our input is valid or not
  - can be easily added as passess in our compiler
  - detection is early if the pass produces an invalid program

- this is a form of *property-based testing* which catches more bugs than unit testing


- what does validator actually checks to ensure *no undefined behaviour*?
  - The input conforms to the grammar of Paren-x64 v1, including restrictions regarding the valid range of integers and when the same register must appear in two places.

  - No register is referred to before is it initialized. We assume that no register is initialized at the beginning of a program.

    - The register rax is initialized before the end of the program.

- we'll write two seperate functions to enable seperation of concerns i.e., we might not always want register to be initialized or so

- first to check the syntax is valid, we've function that takes arb value and returns if it is a valid paren-x64 syntax or raise error with descriptive message ```(check-paren-x64-syntax x) → paren-x64-v1? x : any/c``` 

- now, to check if the register has been initialized before we write this function : ``` (check-paren-x64-init x) → paren-x64-v1?
x : paren-x64-v1?```
  - this takes in a valid paren-x64-syntax and returns a valid paren-x64-program or raises error with descriptive message

- In some examples, the reference implementation raises contract errors when the input is invalid.
  - The reference implementation uses contracts on every pass to detect invalid input and output. These errors are separate from the errors raised by the validator.

### Reflection
good read about enforcing our assumptions we discussed when we definining our source language. tomorrow we'll get to compiling

---
