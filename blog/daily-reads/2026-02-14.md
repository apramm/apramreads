# Day 7 : Feb 14, 2026

## Two Pages Challenge

Today we read about defining source language i.e., capturing the abstraction we learnt about in its own language

### What I Read Today

-   we start by defining their abstract syntax via an **eBNF grammar**

- earlier we described our instruction sequences in concrete syntax of x64 and strings but it's difficult for compiler as it contains unnecessary details useful for humans but irrelevant to machines

    - example, strings are difficult to work with as they lack structure for conveniently accessing substructures, and whitespace sensitivity means two identical programs have multiple representations. 

- from now we'll use abstract syntax which is represented as `quasiquoted data`, so the expression (begin (set! rax 42)) is represented in Racket as `(begin (set! rax 42))

- new language `Paren-x64 v1`
    - program, p, begins with begin, followed by a sequence of statements (instructions)
    -  The non-terminal p defines the instruction sequence abstraction
    ```
    (define (p-append p1 p2)
  (match `(,p1 ,p2)
    [`((begin ,s1 ...) (begin ,s2 ...))
     `(begin ,@s1 ,@s2)]))
    ```

    - each instruction *s*, orresponds to one of the x64 instructions described earlier. For example, the x64 instruction `mov reg, integer` corresponds to the Paren-x64 v1 instruction `set! reg integer`.  
    - instruction `add reg, integer` is represented `set! reg (+ reg integer)`

- what we trynna do with this abstraction?
    - makes more clear that the arithmetic operations are actually a combination of an arithmetic operation and an operation that changes state
    - Some restrictions from x64 are not apparent in the definition of the grammar
        - Any time we suffix a non-terminal by an underscore and a number, such as `reg_1`, this is a reference to a particular instance of a non-terminal, and it is restricted to be identical to any other instance of the same non-terminal with the same underscore suffix within the same expression.
        -  So `(set! reg_1 (+ reg_1 integer))` represents an add instruction in Paren-x64 v1, and both occurrences of `reg_1` must be the same register. 
        - However, two instances of non-terminals with different suffixes, like `reg_1` and `reg_2`, are not necessarily differentâ€”they are only not guaranteed to be the same.
        - As usual in eBNF, any reference to a non-terminal without an underscore is also unrestricted. For example, in (set! reg reg), neither occurrence of reg is guaranteed to be the same nor different
        - Any non-terminal that is not defined as syntax, such as `int64`, may be defined by a Racket predicate, such as `int64?`. 

        parent-x64 v1 rules:
        ```
        p	 ::=	 	(begin s ...)
                        
        s	::=	 
                |	    (set! reg int64)
                |	 	(set! reg reg)
                |	 	(set! reg_1 (binop reg_1 int32))
                |	 	(set! reg_1 (binop reg_1 reg))
                        
        reg	 	::=	
                |       rsp
                |	 	rbp
                |	 	rax
                |	 	rbx
                |	 	rcx
                |	 	rdx
                |	 	rsi
                |	 	rdi
                |	 	r8
                |	 	r9
                |	 	r10
                |	 	r11
                |	 	r12
                |	 	r13
                |	 	r14
                |	 	r15
                        
        binop	::=
                |	 	*
                |	 	+
                        
        int64	 	::=	 	int64?
        ```

### Reflection
good reading about grammar and how its compiled of a new language, tomorrow we understand it in a deeper meaning

---
