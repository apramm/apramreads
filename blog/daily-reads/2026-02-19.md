# Day 12 : Feb 19, 2026

## Two Pages Challenge

Today we read start reading about whether the compiler we implemented is correct at all or not?

### What I Read Today

- recall what all we've till now : a compiler i.e., the meaning of all our languages is fully defined. As the compiler can easily translate our abstract language to the x64 i.e., machine language so, it has a meaning
- secondly, we also have "interpreter" for source language to define its meaning and also an intepreter for target language

- so, how do we know if our compiler for `Paren-x64 v1` is correct?
  - the meaning (as defined by intepreter) of a program *p* is the value *integer_1*
  - we compile *p* and execute it as `x64` program and get the value *integer_2*
  - the values *integer_1* and *integer_2* are equivalent. In general, we have to define equivalence for each pair of source and target languages. In this case, the interpreter and the compiler should return the same value.

- we could have instead defined its meaning as the final value of `rax`, and then defined equivalence between `Paren-x64 v1` and `x64` differently i.e., the interpreter and compiled programs would produce different results for some programs, but they would always be equivalent modulo 256.

- this gives rise to another design choice : do we restrict the definition of our source language to ensure the compiler is correct, or design a more complex equivalence relation that can decide whether the compiler is correct?
  - here, we keep it simple and choose to ensure that the interpreter and compiler produce the "same" value



---

TO THINK : HOW ARE COMPILER AND INTERPRETER DIFFERENT? DO WE NEED BOTH IF NOT WHICH ONE HAS MORE PROS THAN CONS ? 

**Compiler:**

- Translates entire source code → machine code/intermediate code before execution
- Creates an executable file
Translation happens once, execution happens many times
- Examples: C, C++, Rust, Go

**Interpreter:**

- Reads and executes source code line-by-line at runtime
- No separate executable produced
- Translation and execution happen together
- Examples: Python (CPython), Ruby, JavaScript (original)

**Modern Hybrid Approaches**
Most modern languages use both:

- Python: Compiles to bytecode → interprets bytecode
- Java/C#: Compile to bytecode → JIT compiles hot paths to machine code
- JavaScript (V8): Interprets initially → JIT compiles frequently-used code

Pros and Cons 
- Compiler
  - **Fast** execution as optimized ahead 
  - **Slow** development as recompilers after changes
  - **Hard** to debug as there could be more complications than just source
  - Single executable
  - Deep analysis and optimization possible 
  - Compiler **per platform**
  - **Low** memory usage at runtime

- Interpreter
  - **Slow** execution as overhead per line
  - **Fast** development as immediate feedback
  - **Easy** debug as can run source directly
  - **Need** runtime and source to distribute
  - **Limited** optimization
  - **Runtime** handles platform
  - **Higher** memory usage as runtime overhead

Which one is the best choice?
- it's a design choice i.e.,
  - Performance-critical system? Compiler (C++, Rust)
  - Rapid development/scripting: Interpreter heavy (Python, Ruby)
  - Best of both? JIT Compilation (Java, JS, Python(modern))

---

- Why we need both usually?
  - intepreter defines the correct semantics/meaning of source language
  - compiler is tested against interpreter



### Reflection
Good read and finished implementing our first interpreter and compiler understanding core concepts for them

Will go forward and understand problems with this simple source language, interpreter and our compiler


---
