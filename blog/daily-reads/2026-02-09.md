# Day 2 : Feb 9, 2026

## Two Pages Challenge

Today we continue reading the compiler construction ( this is about interpreter mainly)

### What I Read Today

Introduction to Compiler Construction

- x64 programs are understood by looking at how they transform machine state (registers + memory) when executed on real hardware.
Unlike high‑level languages, x64 meaning is not “the value of an expression” but the effect of each instruction.

- x64 is not a designed language — it’s a discovered one. The ISA exists because CPUs implement it, not because it’s elegant.

- The “x64” we write is source code for an assembler. The assembler produces a binary format (bin64) that the OS + CPU can run.

- The behaviour of an x64 program is defined by what happens when the binary runs on the CPU (this is the “first interpreter”).

Writing an interpreter for x64 would mean simulating:

- registers

- memory

- instruction semantics

- control flow

but doing this directly over strings is tedious — we’d want structured representations.

TODO: understand how each instruction mutates state, and how sequences of instructions correspond to evaluating expressions in higher‑level languages.

- High‑level languages define meaning via interpreters that compute values.

- x64 defines meaning via state transitions, so understanding it helps us reason about how compiled code “really” behaves.

- The factorial example “crashes” because: there’s no instruction to stop execution
 and there’s no mechanism to return a result to the OS
→ meaning depends on OS conventions, not just CPU semantics.

x64 is not one language — it’s a set of OS‑specific variants.

The CPU ISA is the same, but each OS defines its own rules for how programs start, stop, and interact with the system.

**semantics**
System calls are the OS‑provided primitives for:

- exiting

- printing

- file I/O

**memory allocation**
Without them, a program cannot terminate cleanly or communicate results.

Using system calls makes a program OS‑dependent.
Each OS defines:

- syscall numbers

- calling conventions

- binary formats

entry point labels
→ these differences create distinct “flavours” of x64.

- why this matters?
 The OS defines the runtime contract for x64 programs.

- Compilers must target a specific flavour or abstract over them.

- Understanding syscall conventions is essential before generating assembly.

### Reflection

Good read, about interpreters and sys calls. will be fun to read about different x64s


---
